\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}
\usepackage{subfigure}

\usepackage[brazil]{babel}   
\usepackage[latin1]{inputenc}  
     
\sloppy

\title{MI - Concorrência e Conectividade\\ Acertando os Ponteiros}

\author{Vinicius Pereira Santana$^{1}$}

\address{Graduando em Engenharia de Computação. \\ Universidade Estadual de Feira de Santana (UEFS), Feira de Santana, Brasil.
  \email{vpsantana@ecomp.uefs.br}
}

\begin{document} 

\maketitle

\begin{abstract}
  
\end{abstract}
     
\begin{resumo} 

O presente documento aborda o desenvolvimento do \textit{TimeSynchronizer}, uma solução distribuída com o intuito de sincronizar, aproximadamente, um grupo de relógios físicos, garantindo a monotonicidade temporal. Para isto, conceitos pertinentes sobre Sistemas Distribuídos, Sincronização, Algoritmos de Eleição e arquitetura Cliente/Cliente foram aplicados.  

\end{resumo}

\section{Introdução}

Na modernidade, tempo tornou-se um elemento precioso. Não obstante, sua noção é bastante difusa e, por diversas vezes, é tema de discussões filosóficas e alvo de pesquisas na Física. O que se sabe é que ele norteia a vida das sociedades e constitui-se como moeda de troca nas relações de trabalho.

Nos sistemas computacionais não é diferente. Ter uma referência para a execução das tarefas é importante. Essas tarefas podem ser das mais variadas: desde a criação de um arquivo até a execução de um \textit{back-up} agendado, por exemplo. Entretanto, por um aspecto construtivo, dispositivos diferentes (ou até mesmo iguais) podem mensurar os instantes de maneira diferente e, com o passar do tempo, naturalmente atrasar ou adiantar. Assim, é preciso buscar maneiras confiáveis de manter a sincronização dos relógios. 

Neste aspecto, foi solicitado aos alunos do MI - Concorrência e Conectividade, da Universidade Estadual de Feira de Santana (UEFS), o desenvolvimento de uma solução distribuída para a sincronização aproximada de um grupo definido de relógios físicos com as seguintes características: utilização de um dos relógios como referência com o intuito de manter que o tempo sempre avance (monotonicidade) e a identificação e correção de possíveis falhas. A motivação é apresentar aos alunos os desafios e perspectivas quando é necessário que seja mantida a concordância entre os relógios.

Desse modo, o presente documento apresenta os conhecimentos necessários para a construção da solução solicitada (Seção \ref{desen}), bem como apresenta os resultados obtidos (Seção \ref{resl}). Por fim, são tecidas as conclusões (Seção \ref{concl}).

\section{Desenvolvimento} \label{desen}

Diante da demanda estabelecida, é imediato iniciar o desenvolvimento do sistema com a definição da arquitetura. Se para que a sincronização dos relógios aconteça, os dispositivos devem conectar-se entre si. Desse modo, o modelo Cliente/Cliente deverá ser utilizado.

O modelo Cliente/Cliente é amplamente utilizado em arquiteturas distribuídas ou descentralizadas. Isto não significa que não exista um servidor, significa que a posse desta função é dinâmica, ao contrário do modelo Cliente/Servidor que é estática. Assim, a depender das configurações, estado e objetivos, por exemplo, há troca no cargo de servidores. Recebe também a denominação Peer-to-Peer (P2P) \cite{kurose2010}. 

Outro ponto importante no projeto é a escolha da linguagem de programação. Para o desenvolvimento deste sistema foi escolhida a linguagem Java. A codificação em Java permite um ganho ímpar em portabilidade. Desse modo, independente da plataforma de Sistema Operacional (\textit{Windows}, \textit{Linux} ou \textit{MacOS}), a aplicação funcionará, exigindo apenas a instalação da máquina virtual fornecida pelo Java. Em outras palavras, isso significa praticidade e redução nos custos do projeto \cite{caelum2017}. 

Levando em consideração as informações apresentadas, as subseções seguintes apresentarão conceitos e tópicos necessários ao desenvolvimento desta aplicação.

\subsection{Sistemas Distribuídos}\label{sistdis}

Para \cite{coulouris2012}, um sistema distribuído é aquele cujos componentes localizam-se em computadores interligados em rede e que coordenam suas ações por meio da troca de mensagens. Por exemplo, inclui-se os jogos \textit{multiplayer} online e os sistemas de buscas web. Esta definição consegue caracterizar bem a maioria dos sistemas existentes e faz menção às características de concorrência no uso dos componentes, tolerância às falhas e ausência de um relógio comum. 

%A utilização dos computadores é vital para o funcionamento e realização de diversas atividades. 

A concorrência no uso dos componentes é uma realidade quase que inevitável em uma rede de computadores. Se um grupo de estudantes, nas suas residências, compartilham arquivos e escrevem o trabalho simultaneamente, é importante que o sistema tenha a capacidade de coordenar as ações da melhor forma.  %\textquotedblleft \textquotedblright

Falhas podem acontecer a qualquer instante e é importante que seja dimensionado três itens: identificação das falhas, ações de emergência e os impactos. Assim, por exemplo, mensagens podem não ser recebidas ou atrasarem e os processos podem finalizar de maneira inesperada (\textit{crash}). Em qualquer situação, o sistema deve continuar funcionando corretamente.

A ausência de um relógio comum justifica-se em dois aspectos. O primeiro, como abordado anteriormente, é um aspecto construtivo: os dispositivos tendem a contabilizar diferente o tempo. Além disso, como é provável que os dispositivos estejam em locais distintos do mundo, questões de fuso horário são pertinentes. Neste cenário, é natural que aconteçam diferenças. Em sistemas nos quais tempo é um elemento crucial, isto pode inviabilizar o funcionamento. Neste contexto, o uso de mensagens e a noção de causalidade (um evento só pode acontecer após o acontecimento de um determinado evento anterior) é indispensável. Mas, se a sincronização for inevitável, é importante lançar mão de alguma estratégia.

\subsection{Sincronização Temporal em Sistemas Distribuídos}

O grande trunfo da sincronização temporal, nos sistemas distribuídos, é fazer com que os componentes concordem com uma determinada hora, não necessariamente a hora tida como a correta. Não obstante, para haver consistência temporal, é importante que a política seja mantida. 

Neste plano, o algoritmo contido no \textit{Berkley Software Distribuition} (BSD) é uma solução elegante (Figura \ref{fig:bsd}). Quando uma sincronização é necessária, um coordenador (escolhido previamente e que atende ao conceito de servidor dinâmico) envia sua estampa aos outros dispositivos e estes respondem com a diferença. Por fim, o coordenador avalia as diferenças recebidas e responde com o ajuste que cada dispositivo deve fazer para manter-se sincronizado. Assim, a concordância temporal é alcançada \cite{coulouris2012}. Entretanto, esta solução permite que tempo possa avançar ou retroceder, pois o ajuste mantém relação de dependência com quem ocupa o cargo de coordenador. Em aplicações críticas, tal comportamento temporal é indesejado.

\begin{figure}[tbph]
	\centering
	\includegraphics[scale=1]{bsd.png}
	\caption{(a) O coordenador envia seu horário aos outros dispositivos. (b) Os dispositivos respondem com a diferença. (c) O coordenador envia qual ajuste deve ser feito \cite{tannem2007}.}
	\label{fig:bsd}
\end{figure}

Com o objetivo de adaptar o algoritmo para o desenvolvimento do sistema proposto, duas modificações foram feitas: 

\begin{itemize}
	\item[1º)] A escolha do coordenador é baseada em critérios que garantem a monotonicidade temporal. Em outras palavras, coordenadores (servidores dinâmicos) são aqueles cuja estampa de tempo é a maior entre as demais, momentaneamente.
	\item[2º)] O coordenador envia sua estampa de tempo em períodos fixos. Deste modo, todos os dispositivos constantemente são sincronizados.
\end{itemize}

\subsection{Algoritmo de Eleição}

As partes integrantes de um sistema distribuído necessitam manter certo nível de organização. Um modo de manter a organização é a existência de hierarquia. Desse modo, é preciso determinar, mesmo que por um instante ou não, quem será responsável por enviar as estampas e quem as receberá. Na literatura, esta coordenação é provida por um algoritmo de eleição.%não sendo diferente no desenvolvimento desta solução. 

O objetivo mais simples desta classe é permitir que alguém possa conduzir a realização de uma determinada tarefa. Não obstante, é fornecido também uma modo para identificar possíveis falhas e providências. Aqui, falha é compreendida como a não resposta do coordenador corrente ou estampa de tempo enviada sem assegurar a monotonicidade do tempo. Na arquitetura proposta, foi escolhido a utilização do Algoritmo de \textit{Bully} (tradução livre, Valentão), com modificações \cite{coulouris2012}, \cite{tannem2007}.

O algoritmo define três tipos básico de mensagens. A primeira é uma convocatória para a realização de uma eleição. A segunda consiste de uma resposta para um pedido de eleição. Por fim, uma mensagem que notifica o vencedor da eleição que, em outras palavras, será o coordenador.

Para avaliar o funcionamento, é importante considerar a existência de um processo $P$ que pode ter se recuperado de uma falha ou identificou a ocorrência de uma falha. As seguintes ações são possíveis \cite{coulouris2012}, \cite{tannem2007}, \cite{wikibully2017}:

%If P has the highest process id, it sends a Victory message to all other processes and becomes the new Coordinator. Otherwise, P broadcasts an Election message to all other processes with higher process IDs than itself.
%If P receives no Answer after sending an Election message, then it broadcasts a Victory message to all other processes and becomes the Coordinator.
%If P receives an Answer from a process with a higher ID, it sends no further messages for this election and waits for a Victory message. (If there is no Victory message after a period of time, it restarts the process at the beginning.)
%If P receives an Election message from another process with a lower ID it sends an Answer message back and starts the election process at the beginning, by sending an Election message to higher-numbered processes.
%If P receives a Coordinator message, it treats the sender as the coordinator.

\begin{itemize}
	\item Se $P$ possui a maior identificação (neste caso, estampa de tempo), ele envia uma mensagem de vitória. Caso contrário, somente os que possuem maiores identificações são notificados sobre a eleição.
	\item Se $P$ não recebe nenhuma resposta após o início de uma eleição, então ele envia uma mensagem de vitória.
	\item Se $P$ recebe uma resposta de um processo com maior identificação, $P$ não enviará mais mensagens e aguardará uma mensagem de vitória. (Caso não haja mensagem de vitória, o processo é reiniciado).
	\item Se $P$ recebe uma mensagem de eleição de um processo com menor identificação, $P$ envia uma resposta e inicia uma nova eleição. 
	\item Se $P$ recebe uma mensagem que possui uma estampa de tempo, $P$ trata o remetente como coordenador.
\end{itemize} 
Na implementação corrente, quando $P$ identifica a ocorrência de falha, este assume o papel de coordenador, sem iniciar uma eleição. Caso $P$ seja de fato o coordenador, não há modificações. Caso contrário, o sistema vai ajustando-se até encontrar o verdadeiro coordenador. Tal configuração dá mais dinâmica e permite sincronizar mais rapidamente os dispositivos.

\subsection{Implementação Cliente/Cliente}

Para realizar a comunicação entre os dispositivos, com o auxílio do Java, foi definido um grupo de \textit{multicast}. Este é capaz de reunir os interessados em enviar e receber determinadas mensagens. Além disto, \textit{Threads} e o protocolo de transporte UDP foram utilizados também. No aspecto comunicativo, é importante que os dispositivos possam se comunicar de maneira eficiente e padronizada. Desse modo, é importante definir um protocolo de comunicação. As informações estão na Tabela 1.

\begin{center}
	\textbf{Tabela 1. Protocolo de comunicação estabelecido neste \textit{software}.} 
	\begin{tabular}{|c|c|c|}
		\hline 
		\textbf{Operação} & \textbf{Código da Operação} & \textbf{Quantidade de Parâmetros}  \\ 
		\hline 
		Enviar Hora (Eleição) & 1001 & 4 \\ 
		\hline 
		Enviar Hora & 1002 & 3 \\ 
		\hline 
		Realizar Eleição & 1003  & 4 \\ 
		\hline 
		Responder Eleição & 1004  & 2 \\ 
		\hline
		Vencedor Eleição & 1005 & 1 \\ 
		\hline  
	\end{tabular}  
	\textbf{\\ Fonte: Autor.}
\end{center}

A tabela possui 3 colunas: Operação, Código da Operação e Quantidade de Parâmetros. Operação diz respeito as ações que podem ser executadas pelos dispositivos. A coluna seguinte denota o código que identifica a operação. Por fim, a última coluna informa sobre quantidade de parâmetros enviados em uma dada operação.

\section{Resultados}\label{resl}

A primeira versão do sistema, denominado \textit{TimeSynchronizer}, foi construída, levando em consideração os requisitos solicitados. Testes foram executados e os resultados obtidos foram satisfatórios. As Figuras 3(a) e 3(b) apresentam dois dispositivos que possuem as estampas de tempo sincronizadas.  %no Laboratório de Redes e Sistemas Distribuídos

%\begin{figure}[tbph]
%	\centering
%	\includegraphics[scale=0.7]{figure/tela_inicial}
%	\caption{\textit{TimeSynchronizer} em funcionamento.}
%	\label{fig:telainicial}
%\end{figure}



\begin{figure}[htpb]
	\center
	\subfigure[dis1][Relógio do Dispositivo 1]{\includegraphics[scale = 0.65]{dis1.png}}
	\qquad
	\subfigure[Relógio do Dispositivo 2]{\includegraphics[scale = 0.65]{dis2.png}}
	\caption{Imagens do \textit{TimeSynchronizer}.}
	\label{sistemaimgs}
\end{figure}

Ao iniciar a execução, é solicitado que o usuário informe uma identificação para o novo relógio. Logo após, a estampa de tempo  inicial (formato HH:MM:SS) e o \textit{drift}. O \textit{drift} corresponde ao quão rápida ou lenta é uma contagem. Este parâmetro serve para modelar as características construtivas dos dispositivos. Quanto mais próximo de $0$, mais rápida é contabilização do tempo. Para uma contagem regular, o \textit{drift} deve ser $1$.

Após as configurações iniciais, a sincronização tem inicio. Ele é efetuada a cada $5$ segundos. A \textit{thread} associada é responsável por: identificar falhas, modificar coordenador e enviar/receber estampas. Outra \textit{thread} é responsável por efetuar a contagem e exibição da estampa. Por conta da interface minimalista, o estado do sistema é exibido por meio do console para rastrear as ações.

Um outro aspecto considerado na sincronização é o tempo entre o envio e o recebimento da resposta de uma mensagem - \textit{Round-Trip Time} (RTT). Nesta solução, o cálculo do RTT é simulado e pode estar entre $100$ e $1100$ milissegundos (típico de redes locais e das de longas distâncias).  A simulação é feita para avaliar o comportamento do sistema quando os atrasos de rede são pertinentes. Por aspectos de projeto, quando o RTT é maior ou igual a $1000$ milissegundos, há compensação na estampa de tempo enviada (adiciona-se mais um segundo).

\section{Conclusões}\label{concl}

A formação de um profissional de Engenharia de Computação deve buscar ao máximo o desenvolvimento de habilidades e competências que o auxiliem em qualquer ambiente adverso. Neste contexto, insere-se a construção e/ou administração de Sistemas Distribuídos.

Não obstante, foi desenvolvido o \textit{TimeSynchronizer}. Este é uma solução distribuída para a sincronização aproximada de um grupo definido de relógios físicos que é capaz de tratar falhas (\textit{crashes} de coordenador, atrasos de redes, dentre outros). As informações sobre o estado do sistema são apresentados nas interfaces gráfica e de comando. De modo geral, os resultados obtidos foram satisfatórios. No aspecto de melhorias, é sugerido fazer o cálculo real do RTT. 

\bibliographystyle{sbc}
\begin{thebibliography}{}
	
\bibitem[Caelum 2017]{caelum2017} Caelum (2017). \newblock Java e {O}rientação a {O}bjetos - {C}urso {FJ} - 11. Disponível em: \textless www.caelum.com.br/apostilas\textgreater. Acesso em: 8 julho 2017. 
	
\bibitem[Kurose e Ross 2010]{kurose2010} Kurose, F. e Ross, K. (2010). \textit{Redes de computadores e a {I}nternet: uma abordagem top-down}. 5 ed. São Paulo: Pearson.

\bibitem[Coulouris et. al. 2012]{coulouris2012} Coulouris, G., Dollimore, J., Kindberg, T. e Blair, G. (2012). \textit{Distributed {S}ystems:
{C}oncepts and {D}esign}. 5 ed. Boston: Pearson.

\bibitem[Wikipedia, 2017]{wikibully2017} Wikipedia (2017). Bully algorithm. Disponível em: \textless https://en.wikipedia.org/wiki/Bully\_algorithm\textgreater. Acesso em: 26 junho 2017. 

\bibitem[Tannembaum e Steen 2007]{tannem2007} Tanenbaum, A. S., Steen, M. V. (2007)\textit{ Distributed {S}ystems: Principles and Paradims.} 2 ed. Upper Saddle River: Pearson-Pretice Hall.

\end{thebibliography}
%\bibliography{sbc-template}

\end{document}
